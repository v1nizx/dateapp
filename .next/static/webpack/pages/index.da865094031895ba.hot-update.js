"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "(pages-dir-browser)/./services/placeService.ts":
/*!**********************************!*\
  !*** ./services/placeService.ts ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PlacesService: () => (/* binding */ PlacesService)\n/* harmony export */ });\n/* harmony import */ var _utils_info__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/info */ \"(pages-dir-browser)/./utils/info.tsx\");\n\nclass PlacesService {\n    // Fun√ß√£o principal - APENAS GEMINI\n    static async searchPlaces(filters) {\n        try {\n            var _data_places;\n            console.log('ü§ñ Buscando recomenda√ß√µes com Gemini AI...', filters);\n            const response = await fetch(\"\".concat(this.API_BASE_URL, \"/gemini-recommendations\"), {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Authorization': \"Bearer \".concat(_utils_info__WEBPACK_IMPORTED_MODULE_0__.publicAnonKey)\n                },\n                body: JSON.stringify(filters)\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                console.error('Erro na resposta:', errorData);\n                throw new Error(\"HTTP \".concat(response.status, \": \").concat(errorData.error || 'Erro desconhecido'));\n            }\n            const data = await response.json();\n            console.log(\"‚ú® Gemini encontrou \".concat(((_data_places = data.places) === null || _data_places === void 0 ? void 0 : _data_places.length) || 0, \" lugares\"));\n            return data.places || [];\n        } catch (error) {\n            console.error('‚ùå Erro ao buscar recomenda√ß√µes:', error);\n            throw error;\n        }\n    }\n    static async getCurrentLocation() {\n        return new Promise((resolve, reject)=>{\n            if (!navigator.geolocation) {\n                reject(new Error('Geolocaliza√ß√£o n√£o √© suportada neste navegador'));\n                return;\n            }\n            const options = {\n                enableHighAccuracy: false,\n                timeout: 15000,\n                maximumAge: 300000\n            };\n            navigator.geolocation.getCurrentPosition((position)=>{\n                resolve({\n                    latitude: position.coords.latitude,\n                    longitude: position.coords.longitude\n                });\n            }, (error)=>{\n                let errorMessage = 'Erro ao obter localiza√ß√£o';\n                let errorType = 'UNKNOWN';\n                switch(error.code){\n                    case error.PERMISSION_DENIED:\n                        errorMessage = 'PERMISSION_DENIED';\n                        errorType = 'PERMISSION_DENIED';\n                        break;\n                    case error.POSITION_UNAVAILABLE:\n                        errorMessage = 'Localiza√ß√£o indispon√≠vel. Verifique se o GPS est√° ativado.';\n                        errorType = 'POSITION_UNAVAILABLE';\n                        break;\n                    case error.TIMEOUT:\n                        errorMessage = 'Tempo limite excedido ao obter localiza√ß√£o.';\n                        errorType = 'TIMEOUT';\n                        break;\n                }\n                const customError = new Error(errorMessage);\n                customError.type = errorType;\n                reject(customError);\n            }, options);\n        });\n    }\n    static getRandomPlace(places) {\n        if (places.length === 0) return null;\n        const randomIndex = Math.floor(Math.random() * places.length);\n        return places[randomIndex];\n    }\n}\nPlacesService.API_BASE_URL = \"https://\".concat(_utils_info__WEBPACK_IMPORTED_MODULE_0__.projectId, \".supabase.co/functions/v1\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NlcnZpY2VzL3BsYWNlU2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUF3RDtBQVdqRCxNQUFNRTtJQUdYLG1DQUFtQztJQUNuQyxhQUFhQyxhQUFhQyxPQUFxQixFQUFvQjtRQUNqRSxJQUFJO2dCQW1CZ0NDO1lBbEJsQ0MsUUFBUUMsR0FBRyxDQUFDLDhDQUE4Q0g7WUFFMUQsTUFBTUksV0FBVyxNQUFNQyxNQUFNLEdBQXFCLE9BQWxCLElBQUksQ0FBQ0MsWUFBWSxFQUFDLDRCQUEwQjtnQkFDMUVDLFFBQVE7Z0JBQ1JDLFNBQVM7b0JBQ1AsZ0JBQWdCO29CQUNoQixpQkFBaUIsVUFBd0IsT0FBZFgsc0RBQWFBO2dCQUMxQztnQkFDQVksTUFBTUMsS0FBS0MsU0FBUyxDQUFDWDtZQUN2QjtZQUVBLElBQUksQ0FBQ0ksU0FBU1EsRUFBRSxFQUFFO2dCQUNoQixNQUFNQyxZQUFZLE1BQU1ULFNBQVNVLElBQUksR0FBR0MsS0FBSyxDQUFDLElBQU8sRUFBQztnQkFDdERiLFFBQVFjLEtBQUssQ0FBQyxxQkFBcUJIO2dCQUNuQyxNQUFNLElBQUlJLE1BQU0sUUFBNEJKLE9BQXBCVCxTQUFTYyxNQUFNLEVBQUMsTUFBMkMsT0FBdkNMLFVBQVVHLEtBQUssSUFBSTtZQUNqRTtZQUVBLE1BQU1mLE9BQU8sTUFBTUcsU0FBU1UsSUFBSTtZQUNoQ1osUUFBUUMsR0FBRyxDQUFDLHNCQUErQyxPQUF6QkYsRUFBQUEsZUFBQUEsS0FBS2tCLE1BQU0sY0FBWGxCLG1DQUFBQSxhQUFhbUIsTUFBTSxLQUFJLEdBQUU7WUFFM0QsT0FBT25CLEtBQUtrQixNQUFNLElBQUksRUFBRTtRQUMxQixFQUFFLE9BQU9ILE9BQU87WUFDZGQsUUFBUWMsS0FBSyxDQUFDLG1DQUFtQ0E7WUFDakQsTUFBTUE7UUFDUjtJQUNGO0lBRUEsYUFBYUsscUJBQXVFO1FBQ2xGLE9BQU8sSUFBSUMsUUFBUSxDQUFDQyxTQUFTQztZQUMzQixJQUFJLENBQUNDLFVBQVVDLFdBQVcsRUFBRTtnQkFDMUJGLE9BQU8sSUFBSVAsTUFBTTtnQkFDakI7WUFDRjtZQUVBLE1BQU1VLFVBQVU7Z0JBQ2RDLG9CQUFvQjtnQkFDcEJDLFNBQVM7Z0JBQ1RDLFlBQVk7WUFDZDtZQUVBTCxVQUFVQyxXQUFXLENBQUNLLGtCQUFrQixDQUN0QyxDQUFDQztnQkFDQ1QsUUFBUTtvQkFDTlUsVUFBVUQsU0FBU0UsTUFBTSxDQUFDRCxRQUFRO29CQUNsQ0UsV0FBV0gsU0FBU0UsTUFBTSxDQUFDQyxTQUFTO2dCQUN0QztZQUNGLEdBQ0EsQ0FBQ25CO2dCQUNDLElBQUlvQixlQUFlO2dCQUNuQixJQUFJQyxZQUFZO2dCQUVoQixPQUFRckIsTUFBTXNCLElBQUk7b0JBQ2hCLEtBQUt0QixNQUFNdUIsaUJBQWlCO3dCQUMxQkgsZUFBZTt3QkFDZkMsWUFBWTt3QkFDWjtvQkFDRixLQUFLckIsTUFBTXdCLG9CQUFvQjt3QkFDN0JKLGVBQWU7d0JBQ2ZDLFlBQVk7d0JBQ1o7b0JBQ0YsS0FBS3JCLE1BQU15QixPQUFPO3dCQUNoQkwsZUFBZTt3QkFDZkMsWUFBWTt3QkFDWjtnQkFDSjtnQkFFQSxNQUFNSyxjQUFjLElBQUl6QixNQUFNbUI7Z0JBQzlCTSxZQUFZQyxJQUFJLEdBQUdOO2dCQUNuQmIsT0FBT2tCO1lBQ1QsR0FDQWY7UUFFSjtJQUNGO0lBRUEsT0FBT2lCLGVBQWV6QixNQUFlLEVBQWdCO1FBQ25ELElBQUlBLE9BQU9DLE1BQU0sS0FBSyxHQUFHLE9BQU87UUFDaEMsTUFBTXlCLGNBQWNDLEtBQUtDLEtBQUssQ0FBQ0QsS0FBS0UsTUFBTSxLQUFLN0IsT0FBT0MsTUFBTTtRQUM1RCxPQUFPRCxNQUFNLENBQUMwQixZQUFZO0lBQzVCO0FBQ0Y7QUF0RmEvQyxjQUNhUSxlQUFlLFdBQXFCLE9BQVZWLGtEQUFTQSxFQUFDIiwic291cmNlcyI6WyIvaG9tZS9tYXJjb3NyaW9zL0RvY3VtZW50b3MvR2l0SHViL3Byb2pldG9fZGF0ZS9zZXJ2aWNlcy9wbGFjZVNlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcHJvamVjdElkLCBwdWJsaWNBbm9uS2V5IH0gZnJvbSAnLi4vdXRpbHMvaW5mbydcbmltcG9ydCB7IFBsYWNlIH0gZnJvbSAnLi4vZGF0YS9tb2NrUGxhY2VzJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFBsYWNlRmlsdGVycyB7XG4gIGJ1ZGdldDogc3RyaW5nXG4gIHR5cGU6IHN0cmluZ1xuICBwZXJpb2Q6IHN0cmluZ1xuICBsYXRpdHVkZTogbnVtYmVyXG4gIGxvbmdpdHVkZTogbnVtYmVyXG59XG5cbmV4cG9ydCBjbGFzcyBQbGFjZXNTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgQVBJX0JBU0VfVVJMID0gYGh0dHBzOi8vJHtwcm9qZWN0SWR9LnN1cGFiYXNlLmNvL2Z1bmN0aW9ucy92MWBcblxuICAvLyBGdW7Dp8OjbyBwcmluY2lwYWwgLSBBUEVOQVMgR0VNSU5JXG4gIHN0YXRpYyBhc3luYyBzZWFyY2hQbGFjZXMoZmlsdGVyczogUGxhY2VGaWx0ZXJzKTogUHJvbWlzZTxQbGFjZVtdPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCfwn6SWIEJ1c2NhbmRvIHJlY29tZW5kYcOnw7VlcyBjb20gR2VtaW5pIEFJLi4uJywgZmlsdGVycylcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLkFQSV9CQVNFX1VSTH0vZ2VtaW5pLXJlY29tbWVuZGF0aW9uc2AsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3B1YmxpY0Fub25LZXl9YFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShmaWx0ZXJzKVxuICAgICAgfSlcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSlcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJybyBuYSByZXNwb3N0YTonLCBlcnJvckRhdGEpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c306ICR7ZXJyb3JEYXRhLmVycm9yIHx8ICdFcnJvIGRlc2NvbmhlY2lkbyd9YClcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgICAgY29uc29sZS5sb2coYOKcqCBHZW1pbmkgZW5jb250cm91ICR7ZGF0YS5wbGFjZXM/Lmxlbmd0aCB8fCAwfSBsdWdhcmVzYClcblxuICAgICAgcmV0dXJuIGRhdGEucGxhY2VzIHx8IFtdXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvIGFvIGJ1c2NhciByZWNvbWVuZGHDp8O1ZXM6JywgZXJyb3IpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBnZXRDdXJyZW50TG9jYXRpb24oKTogUHJvbWlzZTx7IGxhdGl0dWRlOiBudW1iZXI7IGxvbmdpdHVkZTogbnVtYmVyIH0+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKCFuYXZpZ2F0b3IuZ2VvbG9jYXRpb24pIHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignR2VvbG9jYWxpemHDp8OjbyBuw6NvIMOpIHN1cG9ydGFkYSBuZXN0ZSBuYXZlZ2Fkb3InKSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIGVuYWJsZUhpZ2hBY2N1cmFjeTogZmFsc2UsXG4gICAgICAgIHRpbWVvdXQ6IDE1MDAwLFxuICAgICAgICBtYXhpbXVtQWdlOiAzMDAwMDBcbiAgICAgIH1cblxuICAgICAgbmF2aWdhdG9yLmdlb2xvY2F0aW9uLmdldEN1cnJlbnRQb3NpdGlvbihcbiAgICAgICAgKHBvc2l0aW9uKSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICBsYXRpdHVkZTogcG9zaXRpb24uY29vcmRzLmxhdGl0dWRlLFxuICAgICAgICAgICAgbG9uZ2l0dWRlOiBwb3NpdGlvbi5jb29yZHMubG9uZ2l0dWRlXG4gICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgKGVycm9yKSA9PiB7XG4gICAgICAgICAgbGV0IGVycm9yTWVzc2FnZSA9ICdFcnJvIGFvIG9idGVyIGxvY2FsaXphw6fDo28nXG4gICAgICAgICAgbGV0IGVycm9yVHlwZSA9ICdVTktOT1dOJ1xuICAgICAgICAgIFxuICAgICAgICAgIHN3aXRjaCAoZXJyb3IuY29kZSkge1xuICAgICAgICAgICAgY2FzZSBlcnJvci5QRVJNSVNTSU9OX0RFTklFRDpcbiAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gJ1BFUk1JU1NJT05fREVOSUVEJ1xuICAgICAgICAgICAgICBlcnJvclR5cGUgPSAnUEVSTUlTU0lPTl9ERU5JRUQnXG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlIGVycm9yLlBPU0lUSU9OX1VOQVZBSUxBQkxFOlxuICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSAnTG9jYWxpemHDp8OjbyBpbmRpc3BvbsOtdmVsLiBWZXJpZmlxdWUgc2UgbyBHUFMgZXN0w6EgYXRpdmFkby4nXG4gICAgICAgICAgICAgIGVycm9yVHlwZSA9ICdQT1NJVElPTl9VTkFWQUlMQUJMRSdcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGNhc2UgZXJyb3IuVElNRU9VVDpcbiAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gJ1RlbXBvIGxpbWl0ZSBleGNlZGlkbyBhbyBvYnRlciBsb2NhbGl6YcOnw6NvLidcbiAgICAgICAgICAgICAgZXJyb3JUeXBlID0gJ1RJTUVPVVQnXG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IGN1c3RvbUVycm9yID0gbmV3IEVycm9yKGVycm9yTWVzc2FnZSkgYXMgRXJyb3IgJiB7IHR5cGU6IHN0cmluZyB9XG4gICAgICAgICAgY3VzdG9tRXJyb3IudHlwZSA9IGVycm9yVHlwZVxuICAgICAgICAgIHJlamVjdChjdXN0b21FcnJvcilcbiAgICAgICAgfSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgKVxuICAgIH0pXG4gIH1cblxuICBzdGF0aWMgZ2V0UmFuZG9tUGxhY2UocGxhY2VzOiBQbGFjZVtdKTogUGxhY2UgfCBudWxsIHtcbiAgICBpZiAocGxhY2VzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGxcbiAgICBjb25zdCByYW5kb21JbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHBsYWNlcy5sZW5ndGgpXG4gICAgcmV0dXJuIHBsYWNlc1tyYW5kb21JbmRleF1cbiAgfVxufVxuIl0sIm5hbWVzIjpbInByb2plY3RJZCIsInB1YmxpY0Fub25LZXkiLCJQbGFjZXNTZXJ2aWNlIiwic2VhcmNoUGxhY2VzIiwiZmlsdGVycyIsImRhdGEiLCJjb25zb2xlIiwibG9nIiwicmVzcG9uc2UiLCJmZXRjaCIsIkFQSV9CQVNFX1VSTCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsIm9rIiwiZXJyb3JEYXRhIiwianNvbiIsImNhdGNoIiwiZXJyb3IiLCJFcnJvciIsInN0YXR1cyIsInBsYWNlcyIsImxlbmd0aCIsImdldEN1cnJlbnRMb2NhdGlvbiIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwibmF2aWdhdG9yIiwiZ2VvbG9jYXRpb24iLCJvcHRpb25zIiwiZW5hYmxlSGlnaEFjY3VyYWN5IiwidGltZW91dCIsIm1heGltdW1BZ2UiLCJnZXRDdXJyZW50UG9zaXRpb24iLCJwb3NpdGlvbiIsImxhdGl0dWRlIiwiY29vcmRzIiwibG9uZ2l0dWRlIiwiZXJyb3JNZXNzYWdlIiwiZXJyb3JUeXBlIiwiY29kZSIsIlBFUk1JU1NJT05fREVOSUVEIiwiUE9TSVRJT05fVU5BVkFJTEFCTEUiLCJUSU1FT1VUIiwiY3VzdG9tRXJyb3IiLCJ0eXBlIiwiZ2V0UmFuZG9tUGxhY2UiLCJyYW5kb21JbmRleCIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./services/placeService.ts\n"));

/***/ })

});